# 209 – Minimum Size Subarray Sum

**Platform:** LeetCode
**Difficulty:** Medium
**Primary Pattern:** Sliding Window
**Link:** https://leetcode.com/problems/minimum-size-subarray-sum/

---

## Problem Summary
Given an array of positive integers and a positive integer target,
find the minimal length of a subarray whose sum is greater than or equal
to the target. If there is no such subarray, return a zero.

---

## Key Insight
- We can use a sliding window approach that expands the right pointer when we need a larger sum and contracting the left pointer when we have a valid sum.
- One pass through the array with two pointers allows us to efficiently find the minimum length.

---

## Approach
- Initialize two pointers, `left` and `right`, both starting at the beginning of the array.
- Maintain a running sum of the elements between the two pointers (inclusive).
- While the `left` pointer is less than the `right` pointer and the `right` pointer is within bounds:
    - If the running sum is greater than or equal to the target:
        - Update the minimum length if the current window size is smaller.
        - Contract the window by moving the `left` pointer to the right and subtracting the leftmost element from the running sum.
    - If the running sum is less than the target:
        - Expand the window by moving the `right` pointer to the right and adding the new element to the running sum.
        - Note that the new element should only be added if the right pointer is still within bounds.
- If no valid subarray is found, return 0; otherwise, return the minimum length found.

---

## Why This Works
- If the left pointer moves past the right pointer, it means a subarray of size 1 has been found, and there is no need to check any further subarrays.
- The sliding window technique ensures that we only traverse the array once, making it efficient.
- By operating on the boundary of meeting the target, we reduce our calculations to only those necessary to find the minimum length. As we shift the right pointer forwards, we only check positions of the left pointer from the last valid sum onwards.

---

## Edge Cases
- Single element equal to target
- Single element less than target
- All elements less than target

---

## Time & Space Complexity
- Time: O(n) – Each element is visited at most twice (once by each pointer).
- Space: O(1) – Only a few variables are used for tracking pointers and sums.

---

## Common Mistakes
- Not updating the running sum correctly when moving the pointers.
- Failing to check for the case where no valid subarray exists.
- Moving the left pointer before subtracting the leftmost element from the running sum.
- Adding the new element to the running sum without checking if the right pointer is within bounds, or before incrementing the right pointer.

---

## Alternative Solutions
- A similar implementation involves using a for-loop to iterate the right pointer while adjusting the left pointer as far forward as possible in each iteration.