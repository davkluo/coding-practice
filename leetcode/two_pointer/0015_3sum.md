# 15 – 3Sum

**Platform:** LeetCode
**Difficulty:** Medium
**Primary Pattern:** Two Pointer
**Link:** https://leetcode.com/problems/3sum/

---

## Problem Summary
Given an integer array, return all unique triplets that sum to zero without reusing elements.

---

## Key Insight
- Sorting enables a two-pointer approach: fix one element, then use two pointers to find pairs that complete the triplet. 
- Careful duplicate handling at all three positions prevents duplicate triplets.

---

## Approach
1. Sort the array to enable two-pointer technique and easier duplicate detection
2. Iterate through array with index `i` as the first element
3. Skip duplicate values for `i` to avoid duplicate triplets
4. Early termination: if `nums[i] > 0`, break (no valid triplets possible since array is sorted)
5. For each `i`, use two pointers `j` (start at `i+1`) and `k` (start at end)
6. Calculate sum of three elements:
   - If sum > 0: decrement `k` (need smaller value)
   - If sum < 0: increment `j` (need larger value)
   - If sum == 0: found a triplet, add it, increment `j`, and skip duplicates for `j`
7. Continue until all triplets are found and return triplets

---

## Why This Works
- After sorting, for a fixed first element, the two-pointer approach explores all possible pairs efficiently. 
- Moving pointers based on the sum comparison guarantees we check all valid combinations. 
- Skipping duplicates at each level (for `i` and `j`) ensures no duplicate triplets in the result.

---

## Edge Cases
- Empty array or arrays with fewer than 3 elements → return empty list
- All zeros → return `[[0, 0, 0]]`
- No valid triplets → return empty list
- Array where first element > 0 → early termination optimization
- Multiple duplicate values → handle with duplicate-skipping logic

---

## Time & Space Complexity
- Time: O(n²) — O(n log n) for sorting + O(n²) for nested loops (outer loop O(n), inner two-pointer O(n))
- Space: O(1) excluding output array — only uses constant extra space for pointers (O(log n) or O(n) if counting sort space depending on implementation)

---

## Common Mistakes
- Forgetting to skip duplicates for the first element (outer loop) leads to duplicate triplets
- Skipping duplicates only after finding a match, not after pointer movements (less optimal but still correct)
- Off-by-one errors in duplicate-skipping bounds checking

---

## Alternative Solutions
- **HashMap approach**: O(n²) time but more complex — for each pair, check if the complement exists